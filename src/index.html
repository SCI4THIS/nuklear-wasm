<!DOCTYPE html>
<html>
<head>
<title>Nuklear-wasm</title>
<script src="matrix.js">
</script>
<script src="vbo.js">
</script>
<script src="program.js">
</script>
<script src="prag.js">
</script>
<script>
var wasm;
var gl;
var glf;
var memory;
var tail = 0;
var bg = { r: 0.1, g: 0.18, b: 0.24, a: 1.0 };
var draw_stack = { };
var prog = { };
var prag = { };
var vbo = { };
var m = { };
//var table = new WebAssembly.Table({ initial: 2, element: "externref" });
var nuklear = { };
var input = [ ];

function mousemove(e)
{
  let x = e.clientX;
  let y = e.clientY;
  input.push([ wasm.instance.exports.nk_input_motion, [nuklear.ctx, x, y ]]);
  draw_gl();
}

function lookup_button(button)
{
  switch (button) {
    case 0:
      return 0; /* NK_BUTTON_LEFT */
  }
  return 0;
}

function mousedown(e)
{
  let x = e.clientX;
  let y = e.clientY;
  let button = lookup_button(e.button);
  input.push([ wasm.instance.exports.nk_input_button, [ nuklear.ctx, button, x, y, true ]]);
  draw_gl();
}

function mouseup(e)
{
  let x = e.clientX;
  let y = e.clientY;
  let button = lookup_button(e.button);
  input.push([ wasm.instance.exports.nk_input_button, [ nuklear.ctx, button, x, y, false ]]);
  draw_gl();
}

function lookup_cmap_glyph_sub(cmap, char_code)
{
  switch (cmap.format) {
    case 0: return null;
    case 4:
      let i;
      let length = cmap.startCode.length;
      if (length != cmap.endCode.length) {
        alert("cmap length mismatch startCode != endCode");
        return null;
      }
      if (length != cmap.idRangeOffset.length) {
        alert("cmap length mismatch startCode != idRangeOffset");
        return null;
      }
      if (length != cmap.idDelta.length) {
        alert("cmap length mismatch startCode != idDelta");
        return null;
      }
      for (i=0; i<length; i++) {
        if (cmap.startCode[i] <= char_code && char_code <= cmap.endCode[i]) {
          break;
	}
      }
      if (i == length) {
        return null;
      }
      if (cmap.idRangeOffset[i] == 0) {
        return cmap.idDelta[i] + char_code;
      }
      let index_offset = i + cmap.idRangeOffset[i] / 2 + (char_code - cmap.startCode[i]);
      if (index_offset < cmap.idRangeOffset.length) {
        return cmap.idRangeOffset[index_offset];
      }
      if (index_offset - length < cmap.glyphIdArray.length) {
        return cmap.glyphIdArray[index_offset - length];
      }
      return null;
      break;
    case 6:
      if (cmap.firstCode <= char_code && char_code < (cmap.firstCode + cmap.entryCount)) {
        return cmap.glyphIdArray[char_code - cmap.firstCode];
      }
      return null;
    default:
      alert("(Lookup) Unhandled format: " + cmap.format);
      break;

  }
}

function lookup_cmap_glyph(cmap, char_code)
{
  let ret = null;
  for (let i=0; i<cmap.subtables.length; i++) {
    ret = lookup_cmap_glyph_sub(cmap.subtables[i], char_code);
    if (ret != null) {
      break;
    }
  }
  return ret;
}

function s_printf_f(modifier, data, output_type)
{
  let data_orig = data;
  let n2 = (1 << 24) * memory[data + 3] +
           (1 << 16) * memory[data + 2] +
           (1 <<  8) * memory[data + 1] +
           (1 <<  0) * memory[data + 0];
  data += 4;
  let n1 = (1 << 24) * memory[data + 3] +
           (1 << 16) * memory[data + 2] +
           (1 <<  8) * memory[data + 1] +
           (1 <<  0) * memory[data + 0];
  let sign = 0;
  if (n1 & 0x80000000) {
    sign = 1;
  }
  let exponent = (n1 & 0x7FF00000) >> 20;
  let fraction1 = (n1 & 0x000FFFFF);
  let fraction2 = (n1 & 0x000FFFFF);
  data += 4;
  let s = "" + n1;
  console.log({data_orig, n1, n2, sign, exponent, fraction1, fraction2});
  return { s: s, n: data - data_orig };
}

function s_printf_d(modifier, data, output_type)
{
  let left_align = false;
  let zero_pad = false;
  let i = 0;
  let data_orig = data;
  if (modifier[i] == '-') {
    left_align = true;
    i++;
  }
  if (modifier[i] == '0') {
    zero_pad = true;
    i++;
  }
  let width = 0;
  if (i >= modifier.length) {
  } else if (modifier[i] == '*') {
    width = (1 << 24) * memory[data + 3] +
            (1 << 16) * memory[data + 2] +
            (1 <<  8) * memory[data + 1] +
            (1 <<  0) * memory[data + 0];
    data += 4;
  } else if ('1' <= modifier[i] && modifier[i] <= '9') {
    width = Number(modifier.substr(i));
  } else {
    console.error("Unhandled modifier: " + modifier);
  }

  let n = (1 << 24) * memory[data + 3] +
          (1 << 16) * memory[data + 2] +
          (1 <<  8) * memory[data + 1] +
          (1 <<  0) * memory[data + 0];
  data += 4;

  let s;
  if (output_type == 'd') {
    s = n.toString(10);
  } else if (output_type == 'x') {
    s = n.toString(16);
  } else if (output_type == 'X') {
    s = n.toString(16).toUpperCase();
  }
  if (width != 0) {
    let adjust = width - s.length;
    for (let i=0; i<adjust; i++) {
      if (left_align) {
        s = s + " ";
      } else if (zero_pad) {
        s = "0" + s;
      } else {
        s = " " + s;
      }
    }
  }

  return { s: s, n: data - data_orig };
}


function s_from_printf(i32_1, i32_2)
{
  let fmt = i32_1;
  let data = i32_2;
  let s = "";
  let i = 0;
  let modifier = "";
  while (memory[fmt + i] != 0) {
    let c = String.fromCharCode(memory[fmt + i]);
    if (c != '%') {
      s += String.fromCharCode(memory[fmt + i]);
      i++;
      modifier = "";
      continue;
    }
    let is_modifier = false;
    i++;
    do {
      c = String.fromCharCode(memory[fmt + i]);
      is_modifier = false;
      switch (c) {
        case '%': s += "%"; break;
        case '-':
        case '*':
        case ' ':
        case '0': case '1': case '2': case '3': case '4':
        case '5': case '6': case '7': case '8': case '9':
          modifier += c;
          is_modifier = true;
          break;
        case 'f':
          res = s_printf_f(modifier, data, c);
          data += res.n;
          s += res.s;
          break;
        case 'd': 
        case 'x': 
        case 'X': 
          res = s_printf_d(modifier, data, c);
          data += res.n;
          s += res.s;
          break;
        case 'p':
          res = s_printf_d("08X", data, 'X');
          data += res.n;
          s += "0x" + res.s;
          break;
        case 'c':
          let cc = (1 << 24) * memory[data + 3] +
                   (1 << 16) * memory[data + 2] +
                   (1 <<  8) * memory[data + 1] +
                   (1 <<  0) * memory[data + 0];
          data += 4;
          s += String.fromCharCode(cc);
          break;
        case 's':
          let s_n = (1 << 24) * memory[data + 3] +
                    (1 << 16) * memory[data + 2] +
                    (1 <<  8) * memory[data + 1] +
                    (1 <<  0) * memory[data + 0];
          data += 4;
          let s_c = memory[s_n];
          while (s_c != 0) {
            s += String.fromCharCode(s_c);
            s_n++;
            s_c = memory[s_n];
          }
          break;
        default:
          s += "%" + modifier + c;
          break;
      }
      i++;
    } while (is_modifier);
  }
  return s;
}

function resize()
{
  let el = document.getElementById("canvas");
  el.width = window.innerWidth;
  el.height = window.innerHeight;
  gl.viewport(0,0,el.width,el.height);
  m.caM.set(0, 0, 2 / el.width);
  m.caM.set(1, 1, -2 / el.height);
  m.caM.set(0, 3, -1.0);
  m.caM.set(1, 3, 1.0);
  draw_gl();
}

function init_nk()
{
  console.log("init.nk()");
  nuklear.ctx = malloc_int(18328);
  nuklear.cmds = malloc_int(120);
  nuklear.rect = malloc_int(16);
  nuklear.s = {
    Demo: c_str("Demo"),
    button: c_str("button"),
    easy: c_str("easy"),
    hard: c_str("hard"),
  }
  nuklear.glfont = wasm.instance.exports.alloc_nk_glfont(16.0, 10.512);
  nuklear.drawcmd = malloc_int(32);
  nuklear.op = 1;
  wasm.instance.exports.nk_init_default(nuklear.ctx, nuklear.glfont);
  wasm.instance.exports.nk_buffer_init_default(nuklear.cmds);
}


function create_prag_glf(caM_data, vbo)
{
  return Prag({
    gl: gl,
    vars: {
      coord: [ 'vertexAttribPointer', 2, gl.FLOAT, false, 4 * 4, 0 ],
      texCoord: [ 'vertexAttribPointer', 2, gl.FLOAT, false, 4 * 4, 2 * 4 ],
      caM: [ 'uniformMatrix4fv', false, caM_data ]
    },
    vbo: {
      coord: vbo,
      texCoord: vbo
    }
  });
}

function create_prog_glf()
{
  let options = {
    gl: gl,
    src: { },
    location_fx: {
      coord: 'getAttribLocation',
      texCoord: 'getAttribLocation',
      caM: 'getUniformLocation'
    },
    enable_fx: {
      coord: 'enableVertexAttribArray',
      texCoord: 'enableVertexAttribArray',
    }
  }
  options.src[gl.VERTEX_SHADER] = `
precision highp float;
attribute vec2  coord;
attribute vec2  texCoord;
varying   vec2  st;
uniform   mat4  caM;

void main() {
  st = texCoord;
  gl_Position = caM * vec4(coord.x, coord.y, 0.0, 1.0);
}
`;

  options.src[gl.FRAGMENT_SHADER] = `
precision highp float;
varying vec2 st;
void main() {
  float flip  = 0.0;
  float s     = st.x;
  float t     = st.y;
  float alpha = 1.0;
  if (t < 0.0) {
    flip = 1.0;
    t    = -t;
  }
  if (1.0 - (s * s) < t) {
    alpha = flip;
  } else {
    alpha = 1.0 - flip;
  }
  if (alpha == 1.0) {
    gl_FragColor = vec4(1.0, 1.0, 1.0, alpha);
  } else {
    discard;
  }
}
`;
  return Program(options);
}

function create_prog_shape()
{
  let options = {
    gl: gl,
    src: { },
    location_fx: {
      coord: 'getAttribLocation',
      color: 'getAttribLocation',
      mode_st: 'getAttribLocation',
      caM: 'getUniformLocation'
    },
    enable_fx: {
      coord: 'enableVertexAttribArray',
      color: 'enableVertexAttribArray',
      mode_st: 'enableVertexAttribArray'
    }
  }
  options.src[gl.VERTEX_SHADER] = `
precision highp float;
attribute vec2  coord;
attribute vec4  color;
attribute vec4  mode_st;

varying   vec4  frag_color;
varying   vec4  frag_mode_st;

uniform   mat4  caM;

void main() {
  frag_color   = color;
  frag_mode_st = mode_st;

  gl_Position = caM * vec4(coord.x, coord.y, 0.0, 1.0);
}
`;

  options.src[gl.FRAGMENT_SHADER] = `
precision highp float;
varying vec4 frag_color;
varying vec4 frag_mode_st;

void main() {
  if (frag_mode_st[0] == 0.0) {
    gl_FragColor = frag_color;
  } else if (frag_mode_st[0] == 1.0) {
    float s = frag_mode_st[1];
    float t = frag_mode_st[2];
    if ((s * s + t * t) <= 1.0) {
      gl_FragColor = frag_color;
    } else {
      discard;
    }
  } else if (frag_mode_st[0] == 2.0) {
    float s = frag_mode_st[1];
    float t = frag_mode_st[2];
    float lt = frag_mode_st[3];
    float mag = sqrt((s * s) + (t * t));
    if (mag <= (1.0 + lt) && mag >= (1.0 - lt)) {
      gl_FragColor = frag_color;
    } else {
      discard;
    }
  }
}
`;
  return Program(options);
}

function create_prag_shape(caM_data, vbo)
{
  return Prag({
    gl: gl,
    vars: {
      mode_st: [ 'vertexAttribPointer', 4, gl.FLOAT, false, 4 * 10, 4 * 0 ],
      color:   [ 'vertexAttribPointer', 4, gl.FLOAT, false, 4 * 10, 4 * 4 ],
      coord:   [ 'vertexAttribPointer', 2, gl.FLOAT, false, 4 * 10, 4 * 8 ],
      caM: [ 'uniformMatrix4fv', false, caM_data ]
    },
    vbo: {
      coord: vbo,
      color: vbo,
      mode_st: vbo
    }
  });
}

function add_shape_pt(i,x,y,r,g,b,a,mode,s,t,lt)
{
  m["shape"].set(0,i,mode);
  m["shape"].set(1,i,s);
  m["shape"].set(2,i,t);
  m["shape"].set(3,i,lt);
  m["shape"].set(4,i,r);
  m["shape"].set(5,i,g);
  m["shape"].set(6,i,b);
  m["shape"].set(7,i,a);
  m["shape"].set(8,i,x);
  m["shape"].set(9,i,y);
}

function add_shape_rect(i,x,y,w,h,r,g,b,a)
{
  add_shape_pt(i++, x+0, y+0, r, g, b, a, 0, 0, 0);
  add_shape_pt(i++, x+w, y+0, r, g, b, a, 0, 0, 0);
  add_shape_pt(i++, x+0, y+h, r, g, b, a, 0, 0, 0);

  add_shape_pt(i++, x+w, y+0, r, g, b, a, 0, 0, 0);
  add_shape_pt(i++, x+0, y+h, r, g, b, a, 0, 0, 0);
  add_shape_pt(i++, x+w, y+h, r, g, b, a, 0, 0, 0);

  return i;
}

function add_shape_rect_corner(i,x,y,w,h,r,g,b,a,corner,lt)
{
/* 0 - lower left */
/* 1 - lower right */
/* 2 - upper left */
/* 3 - upper right */
  switch (corner) {
    case 0:
      add_shape_pt(i++, x+0, y+0, r, g, b, a, 2, -1, -1, lt);
      add_shape_pt(i++, x+w, y+0, r, g, b, a, 2, 0, -1, lt);
      add_shape_pt(i++, x+0, y+h, r, g, b, a, 2, -1, 0, lt);

      add_shape_pt(i++, x+w, y+0, r, g, b, a, 2, 0, -1, lt);
      add_shape_pt(i++, x+0, y+h, r, g, b, a, 2, -1, 0, lt);
      add_shape_pt(i++, x+w, y+h, r, g, b, a, 2, 0, 0, lt);
      break;
    case 1:
      add_shape_pt(i++, x+0, y+0, r, g, b, a, 2, 0, -1, lt);
      add_shape_pt(i++, x+w, y+0, r, g, b, a, 2, 1, -1, lt);
      add_shape_pt(i++, x+0, y+h, r, g, b, a, 2, 0, 0, lt);

      add_shape_pt(i++, x+w, y+0, r, g, b, a, 2, 1, -1, lt);
      add_shape_pt(i++, x+0, y+h, r, g, b, a, 2, 0, 0, lt);
      add_shape_pt(i++, x+w, y+h, r, g, b, a, 2, 1, 0, lt);
      break;
    case 2:
      add_shape_pt(i++, x+0, y+0, r, g, b, a, 2, -1, 0, lt);
      add_shape_pt(i++, x+w, y+0, r, g, b, a, 2, 0, 0, lt);
      add_shape_pt(i++, x+0, y+h, r, g, b, a, 2, -1, 1, lt);

      add_shape_pt(i++, x+w, y+0, r, g, b, a, 2, 0, 0, lt);
      add_shape_pt(i++, x+0, y+h, r, g, b, a, 2, -1, 1, lt);
      add_shape_pt(i++, x+w, y+h, r, g, b, a, 2, 0, 1, lt);
      break;
    case 3:
      add_shape_pt(i++, x+0, y+0, r, g, b, a, 2, 0, 0, lt);
      add_shape_pt(i++, x+w, y+0, r, g, b, a, 2, 1, 0, lt);
      add_shape_pt(i++, x+0, y+h, r, g, b, a, 2, 0, 1, lt);

      add_shape_pt(i++, x+w, y+0, r, g, b, a, 2, 1, 0, lt);
      add_shape_pt(i++, x+0, y+h, r, g, b, a, 2, 0, 1, lt);
      add_shape_pt(i++, x+w, y+h, r, g, b, a, 2, 1, 1, lt);
      break;
  }

  return i;
}


function init_gl()
{
  let options = { alpha: false };
  let el = document.getElementById("canvas");
  try { gl = el.getContext("webgl", options) } catch (e) { }
  try { gl = gl || canvas.getContext("experimental-webgl", options); } catch(e) { }
  if (gl == null) {
    console.log("couldn't create GL instance");
    return;
  }
  window.onresize = resize;
  init_nk();
  m["pix_xy"] = Matrix(Float32Array, 4, 1, [ 0, 0, 0, 1]);
  m["gl_xy"] = Matrix(Float32Array, 4, 1, [ 0, 0, 0, 1]);
  m["caM"] = matrix(Float32Array, 4, 4);
  m["caM"].identity();
  m["caM_glf"] = matrix(Float32Array, 4, 4);
  prog["shape"] = create_prog_shape();
  prog["glf"] = create_prog_glf();
  m["shape"] = matrix(Float32Array, 10, 16 * 3);
  m["glf_vbo"] = Matrix(Float32Array, 4, glf.pts.length / 4, glf.pts);
  m["glf_vao"] = Matrix(Uint32Array, 1, glf.idx.length, glf.idx);
  vbo["shape"] = VBO({gl: gl, m: m["shape"]});
  vbo["glf_vbo"] = VBO({gl: gl, m: m["glf_vbo"]});
  vbo["glf_vao"] = VBO({gl: gl, m: m["glf_vao"]});
  prag["shape"] = create_prag_shape(m.caM._data, vbo["shape"]);
  prag["glf"] = create_prag_glf(m.caM_glf._data, vbo["glf_vbo"]);


  init_draw_char()
  /*
  window.onkeydown = keydown;
  */
  window.onmousemove = mousemove;
  window.onmousedown = mousedown;
  window.onmouseup   = mouseup;

  resize();
}

function init_draw_char()
{
  let xmin = -203;
  let ymin = -302;
//let xmax = 718
//let ymax=1098
//height = ymax - ymin = 1400
//width = xmax - xmin = 921
  let scale = 0.0010857763300760044;

  m["T"] = Matrix(Float32Array, 4, 4, [ 1, 0, 0, 0,
                                            0, 1, 0, 0,
                                            0, 0, 1,     0,
                                           -xmin, -ymin, 0,     1 ]);

  m["S"] = Matrix(Float32Array, 4, 4, [scale,     0, 0, 0,
                                             0, scale, 0, 0,
                                             0,     0, 1, 0,
                                             0,     0, 0, 1 ]);

  m["ST"] = matrix(Float32Array, 4, 4);
  m["ST"].mul(m["S"], m["T"]);

  m["T2"] = Matrix(Float32Array, 4, 4, [ 1, 0, 0, 0,
                                         0, 1, 0, 0,
                                         0, 0, 1, 0,
                                        -1.0 + (0), 1.0 -(0), 0,   1 ]);

  m["S2"] = Matrix(Float32Array, 4, 4, [ (1),     0, 0, 0,
                                         0,     (1), 0, 0,
                                         0,          0, 1, 0,
                                         0,          0, 0, 1 ]);
  m["ST2"] = matrix(Float32Array, 4, 4);

}

function draw_glyph(arg)
{
  
  let idx = lookup_cmap_glyph(glf.cmap, arg.charCode);
  let tab = arg.glf.lookup[idx];
  if (tab == null) {
    if (arg.charCode != 32) {
      console.log("error looking up: " + arg.charCode);
    }
    return;
  }
  arg.vao.bind(arg.gl.ELEMENT_ARRAY_BUFFER);
  const ext = gl.getExtension("OES_element_index_uint");
  let start = tab.start;
  let len = tab.len;
  arg.gl.drawElements(arg.gl.TRIANGLES, len, arg.gl.UNSIGNED_INT, 4 * start);
}

function draw_char(c,x,y,w,h)
{
  let scale1 = 2 / (this.COLS);
  let scale2 = 2 / (this.LINES);
  m["pix_xy"].set(0,0,x);
  m["pix_xy"].set(1,0,y);
  m["gl_xy"].mul(m["caM"], m["pix_xy"]);
  x = m["gl_xy"].get(0,0);
  y = m["gl_xy"].get(1,0);
  let scalex = m["caM"].get(0,0);
  let scaley = m["caM"].get(1,1);
  w = scalex * w;
  h = -scaley * h;
  m["T2"].set(0, 3, x);
  m["T2"].set(1, 3, y);
  m["S2"].set(0, 0, w);
  m["S2"].set(1, 1, h);
  m["ST2"].mul(m["T2"], m["S2"]);
  m["caM_glf"].mul(m["ST2"], m["ST"]);
  prag["glf"].run(prog["glf"], draw_glyph, { gl: gl, vao: vbo["glf_vao"], glf: glf, charCode: c });
}

function reset_draw_stack()
{
  let keys = [ "rect", "rect_filled", "scissor", "text", "circle_filled", "triangle_filled" ];
  for (let i=0; i<keys.length; i++) {
    let key = keys[i];
    draw_stack[key] = [];
    draw_stack["tri_pt_count"] = 3;
  }
}

function draw_shape(n)
{
  gl.drawArrays(gl.TRIANGLES, 0, n);
}

function draw_gl()
{
  gl.clearColor(bg.r, bg.g, bg.b, bg.a);
  gl.clear(gl.COLOR_BUFFER_BIT + gl.DEPTH_BUFFER_BIT);
  wasm.instance.exports.nk_rect(nuklear.rect, 50, 50, 230, 250);
  wasm.instance.exports.nk_input_begin(nuklear.ctx);
  for (let i=0; i<input.length; i++) {
    let fn = input[i][0];
    let fn_arg = input[i][1];
    fn(...fn_arg);
  }
  wasm.instance.exports.nk_input_end(nuklear.ctx);
  if (wasm.instance.exports.nk_begin(nuklear.ctx, nuklear.s.Demo, nuklear.rect, 87)) {
  //if (wasm.instance.exports.nk_wasm_begin(nuklear.ctx, nuklear.s.Demo, 50.0, 50.0, 230.0, 250.0, 87)) {

    wasm.instance.exports.nk_layout_row_static(nuklear.ctx, 30, 80, 1);
    if (wasm.instance.exports.nk_button_label(nuklear.ctx, nuklear.s.button)) {
      console.log("button pressed");
    }

    wasm.instance.exports.nk_layout_row_dynamic(nuklear.ctx, 30, 2);
    if (wasm.instance.exports.nk_option_label(nuklear.ctx, nuklear.s.easy, nuklear.op == 1)) { nuklear.op = 1; }
    if (wasm.instance.exports.nk_option_label(nuklear.ctx, nuklear.s.hard, nuklear.op == 2)) { nuklear.op = 2; }

  }
  wasm.instance.exports.nk_end(nuklear.ctx);
  reset_draw_stack();
  gl.disable(gl.SCISSOR_TEST);
  wasm.instance.exports.nk_wasm_draw(nuklear.ctx);
  //console.log({draw_stack});
  input = [];
}

function start()
{
  init_gl();
}

function malloc_int(i32)
{
  if (tail == 0) {
    tail = memory.length;
  }
  let memadd  = 5;
  let memsize = i32 + memadd;
  let off = (tail - memsize) % 16;
  off = (off + 5) % 16;
  memsize += off;
  tail = tail - memsize;

  memory[tail + 4] = (memsize / (1 << 24)) % 256;
  memory[tail + 3] = (memsize / (1 << 16)) % 256;
  memory[tail + 2] = (memsize / (1 <<  8)) % 256;
  memory[tail + 1] = (memsize / (1 <<  0)) % 256;
  memory[tail + 0] = 1;
  
  return tail + memadd;
}

function str_c(data)
{
  let s = "";
  let i = 0;
  while (memory[data + i] != 0) {
    s += String.fromCharCode(memory[data + i]);
    i++;
  }
  return s;
}

function c_str(s)
{
  let data = malloc_int(s.length + 1);
  for (let i=0; i<s.length; i++) {
    memory[data + i] = s.charCodeAt(i);
  }
  memory[data + s.length] = 0;
  return data;
}

const importObject = {
  env: {
    memory: new WebAssembly.Memory({ initial: 5, maximum: 32, shared: true }),
    memoryBase: 0,
    __assert_fail: function(i32_1, i32_2, i32_3, i32_4) {
      console.log("__assert_fail(" + i32_1 + "," + i32_2 + "," + i32_3 + "," + i32_4 + ")");
      let s1 = s_from_printf(i32_1, i32_2);
      console.error(s1);
      throw new Error("assert_fail");
    },
    vsnprintf: function (i32_1, i32_2, i32_3, i32_4) {
      return 0;
    },
    malloc: function (i32) {
      console.log("malloc(" + i32 + ")");
      return malloc_int(i32);
    },
    free: function(i32) {
      console.log("free(" + i32 + ")");
      let ptr = i32 - 5;
      memory[ptr] = 0;
      while (memory[tail] == 0 && tail < memory.length) {
        let n = (1 << 24) * memory[tail + 4] +
                (1 << 16) * memory[tail + 3] +
                (1 <<  8) * memory[tail + 2] +
                (1 <<  0) * memory[tail + 1];
        tail = tail + n;
      }
    },
    memcpy: function(i32_1, i32_2, i32_3) {
      console.log("memcpy(" + i32_1 + "," + i32_2 + "," + i32_3 + ")");
      let dst = i32_1;
      let src = i32_2;
      let n = i32_3;
      for (let i=0; i<n; i++) {
        memory[dst + i] = memory[src + i];
      }
      return dst;
    },
    printf: function (i32_1, i32_2) {
      console.log("printf(" + i32_1 + "," + i32_2 + ")");
      let s = s_from_printf(i32_1, i32_2);
      console.log(s);
      return s.length;
    },
    nk_wasm_command_scissor: function(i32_1, i32_2, i32_3, i32_4) {
      let x = i32_1;
      let y = i32_2;
      let w = i32_3;
      let h = i32_4;
	/* This doesn't send a clear signal.
	 * If remains enabled it screws up the button rendering
      gl.enable(gl.SCISSOR_TEST);
      gl.scissor(x,y,w,h);
	*/
      draw_stack["scissor"].push({x,y,w,h});
    },
    nk_wasm_command_line: function(i32) { console.log(" nk_wasm_command_line"); },
    nk_wasm_command_curve: function(i32) { console.log(" nk_wasm_command_curve"); },
    nk_wasm_command_rect: function(i32_1, i32_2, i32_3, i32_4, i32_5, i32_6, i32_7) {
      let rounding = i32_1;
      let line_thickness = i32_2;
      let x = i32_3;
      let y = i32_4;
      let w = i32_5;
      let h = i32_6;
      let nk_color = i32_7;
      let r = wasm.instance.exports.nk_color_r(nk_color);
      let g = wasm.instance.exports.nk_color_g(nk_color);
      let b = wasm.instance.exports.nk_color_b(nk_color);
      let a = wasm.instance.exports.nk_color_a(nk_color);
      if (line_thickness == 0) {
        return;
      }
      let i = 0;
      let lt = line_thickness;
      let rn = rounding;
      let off = lt / 2.0;
        i = add_shape_rect(i, x - off, y + rn, lt, h - 2 * rn, r, g, b, a);
        i = add_shape_rect(i, x + w - off, y + rn, lt, h - 2 * rn, r, g, b, a);

        i = add_shape_rect(i, x + rn, y - off, w - 2 * rn, lt, r, g, b, a);
        i = add_shape_rect(i, x + rn, y + h - off, w - 2 * rn, lt, r, g, b, a);
      if (rn == 0) {
        i = add_shape_rect(i, x - off    , y - off, lt, lt, r, g, b, a);
        i = add_shape_rect(i, x + w - off, y - off, lt, lt, r, g, b, a);

        i = add_shape_rect(i, x - off    , y + h - off, lt, lt, r, g, b, a);
        i = add_shape_rect(i, x + w - off, y + h - off, lt, lt, r, g, b, a);
      } else {
        /* 0 - lower left */
        /* 1 - lower right */
        /* 2 - upper left */
        /* 3 - upper right */
        let frag_lt = lt / (lt + rn);
        i = add_shape_rect_corner(i, x - off    , y - off, lt + rn, lt + rn, r, g, b, a, 0, frag_lt);
        i = add_shape_rect_corner(i, x + w - off - rn, y - off, lt + rn, lt + rn, r, g, b, a, 1, frag_lt);

        i = add_shape_rect_corner(i, x - off    , y + h - off - rn, lt + rn, lt + rn, r, g, b, a, 2, frag_lt);
        i = add_shape_rect_corner(i, x + w - off - rn, y + h - off - rn, lt + rn, lt + rn, r, g, b, a, 3, frag_lt);
      }
      draw_stack["rect"].push({x,y,w,h,rounding,line_thickness,r,g,b,a});
      vbo["shape"].reload();
      prag["shape"].run(prog["shape"], draw_shape, i);
    },
    nk_wasm_command_rect_filled: function(i32_1, i32_2, i32_3, i32_4, i32_5, i32_6) {
      let rounding = i32_1;
      let x = i32_2;
      let y = i32_3;
      let w = i32_4;
      let h = i32_5;
      let nk_color = i32_6;
      let r = wasm.instance.exports.nk_color_r(nk_color);
      let g = wasm.instance.exports.nk_color_g(nk_color);
      let b = wasm.instance.exports.nk_color_b(nk_color);
      let a = wasm.instance.exports.nk_color_a(nk_color);
      let i = 0;
      if (rounding == 0) {
        i = add_shape_rect(i, x, y, w, h, r, g, b, a);
      } else {
        let o = rounding;
        i = add_shape_rect(i, x + o, y + 0, w - 2 * o, o        , r, g, b, a);
        i = add_shape_rect(i, x + 0, y + o, w        , h - 2 * o, r, g, b, a);
        i = add_shape_rect(i, x + o, y + h - o, w - 2 * o, o        , r, g, b, a);

        add_shape_pt(i++, x+o, y+0, r, g, b, a, 1, 0, -1);
        add_shape_pt(i++, x+0, y+o, r, g, b, a, 1, -1, 0);
        add_shape_pt(i++, x+o, y+o, r, g, b, a, 1, 0, 0);

        add_shape_pt(i++, x+w-o, y+0, r, g, b, a, 1, 0, -1);
        add_shape_pt(i++, x+w, y+o, r, g, b, a, 1, 1, 0);
        add_shape_pt(i++, x+w-o, y+o, r, g, b, a, 1, 0, 0);

        add_shape_pt(i++, x+o, y+h, r, g, b, a, 1, 0, 1);
        add_shape_pt(i++, x+0, y+h-o, r, g, b, a, 1, -1, 0);
        add_shape_pt(i++, x+o, y+h-o, r, g, b, a, 1, 0, 0);

        add_shape_pt(i++, x+w-o, y+h, r, g, b, a, 1, 0, 1);
        add_shape_pt(i++, x+w, y+h-o, r, g, b, a, 1, 1, 0);
        add_shape_pt(i++, x+w-o, y+h-o, r, g, b, a, 1, 0, 0);

      }
      vbo["shape"].reload();
      prag["shape"].run(prog["shape"], draw_shape, i);
    },
    nk_wasm_command_rect_multi_color: function(i32) { console.log(" nk_wasm_command_rect_multi_color"); },
    nk_wasm_command_circle: function(i32) { console.log(" nk_wasm_command_circle"); },
    nk_wasm_command_circle_filled: function(i32_1, i32_2, i32_3, i32_4, i32_5) {
      let x = i32_1;
      let y = i32_2;
      let w = i32_3;
      let h = i32_4;
      let color = i32_5;
      let r = wasm.instance.exports.nk_color_r(color);
      let g = wasm.instance.exports.nk_color_g(color);
      let b = wasm.instance.exports.nk_color_b(color);
      let a = wasm.instance.exports.nk_color_a(color);

      let i = 0;

      add_shape_pt(i++, x+0, y+0, r, g, b, a, 1.0, -1.0, -1.0);
      add_shape_pt(i++, x+w, y+0, r, g, b, a, 1.0,  1.0, -1.0);
      add_shape_pt(i++, x+0, y+h, r, g, b, a, 1.0, -1.0,  1.0);

      add_shape_pt(i++, x+w, y+0, r, g, b, a, 1.0,  1.0, -1.0);
      add_shape_pt(i++, x+0, y+h, r, g, b, a, 1.0, -1.0,  1.0);
      add_shape_pt(i++, x+w, y+h, r, g, b, a, 1.0,  1.0,  1.0);

      vbo["shape"].reload();
      prag["shape"].run(prog["shape"], draw_shape, i);
    },
    nk_wasm_command_arc: function(i32) { console.log(" nk_wasm_command_arc"); },
    nk_wasm_command_arc_filled: function(i32) { console.log(" nk_wasm_command_arc_filled"); },
    nk_wasm_command_triangle: function(i32) { console.log(" nk_wasm_command_triangle"); },
    nk_wasm_command_triangle_filled: function(i32_1, i32_2, i32_3, i32_4, i32_5, i32_6, i32_7) {
      let x0 = i32_1;
      let y0 = i32_2;
      let x1 = i32_3;
      let y1 = i32_4;
      let x2 = i32_5;
      let y2 = i32_6;
      let color = i32_7;
      let r = wasm.instance.exports.nk_color_r(color);
      let g = wasm.instance.exports.nk_color_g(color);
      let b = wasm.instance.exports.nk_color_b(color);
      let a = wasm.instance.exports.nk_color_a(color);

      let i = 0;
      add_shape_pt(i++, x0, y0, r, g, b, a, 0, 0, 0);
      add_shape_pt(i++, x1, y1, r, g, b, a, 0, 0, 0);
      add_shape_pt(i++, x2, y2, r, g, b, a, 0, 0, 0);
      vbo["shape"].reload();
      prag["shape"].run(prog["shape"], draw_shape, i);
    },
    nk_wasm_command_polygon: function(i32) { console.log(" nk_wasm_command_polygon"); },
    nk_wasm_command_polygon_filled: function(i32) { console.log(" nk_wasm_command_polygon_filled"); },
    nk_wasm_command_polyline: function(i32) { console.log(" nk_wasm_command_polyline"); },
    nk_wasm_command_text: function(i32_1, i32_2, i32_3, i32_4, i32_5, i32_6, i32_7, i32_8, i32_9, i32_10, i32_11) {
      let font = i32_1;
      let bgcolor = i32_2;
      let fgcolor = i32_3;
      let r = wasm.instance.exports.nk_color_r(fgcolor);
      let g = wasm.instance.exports.nk_color_g(fgcolor);
      let b = wasm.instance.exports.nk_color_b(fgcolor);
      let a = wasm.instance.exports.nk_color_a(fgcolor);
      let x = i32_4;
      let y = i32_5;
      let w = i32_6;
      let h = i32_7;
      let height = i32_8;
      let length = i32_9;
      let s = str_c(i32_10);
      let char_width = height * 0.657;
      //let char_width = height * 0.5;
      let calc_width = char_width * length;
      for (let i=0; i<length; i++) {
        draw_char(s.charCodeAt(i), x + i*char_width, y + 1.2*height, char_width, height);
      }
    },
    nk_wasm_command_image: function(i32) { console.log(" nk_wasm_command_image"); },
    nk_wasm_command_custom: function(i32) { console.log(" nk_wasm_command_custom"); },
  }
};

WebAssembly.instantiateStreaming(fetch("nuklear.wasm"), importObject).then(
//WebAssembly.instantiateStreaming(fetch("nuklear-temp.wasm"), importObject).then(
  function (obj) {
    memory = new Uint8Array(obj.instance.exports.memory.buffer);
    wasm = obj;
    wasm_done = true;
    start();
  }
)
</script>
<script src="IntelMono-glf.js">
</script>
</head>
<body>
<canvas id="canvas" style="position: absolute; right: 0px; bottom: 0px;">
</canvas>
</body>
</html>
